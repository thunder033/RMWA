/**
 * Created by gjrwcs on 10/25/2016.
 */
"use strict";
angular.module('pulsar-warp', [])
    .factory('WarpField', ['MConcurrentOperation', 'AudioData', 'SampleCount', function(MConcurrentOperation, AudioData, SampleCount){
        //Create a web worker with the analysis script
        var fieldGenerator = MConcurrentOperation.create('assets/js/workers/generateAudioField.js');

        function WarpField(){
            //Defining a version as a key so that the 'signature' of the object
            //can be compared without analyzing any specific property
            Object.defineProperty(this, 'v1.1', {configurable: false, value: 1, enumerable: true});
            this.duration = 0;
            this.timeStep = NaN;
            this.gems = null;
        }

        /**
         * Performs analysis to generate "audio field" and then begins play
         * @param clip
         */
        WarpField.generate = (clip) => {
            var warpField = new WarpField();
            //This function renders all of the PCM data for the entire clip into series of buffers
            //The result thousands of buckets of 1024 samples (~800 per minute of play w/ current config)
            return AudioData.renderFrameBuffers(clip)
                .then(result => {
                    warpField.duration = result.duration;
                    //this is the average duration of time for each buffer created
                    warpField.timeStep = (result.duration / result.frameBuffers.length) * 1000;

                    //Invoke the analysis in a separate thread (using a web worker)
                    return fieldGenerator.invoke({
                        sampleRate: result.sampleRate, //How many samples per second
                        frequencyBinCount: SampleCount, //The number of frequency bins
                        frameBuffers: result.frameBuffers //The actual array of frame buffers
                    });
                }).then(result => {
                    warpField.gems = result.audioField; //The "level" generated by the async web worker
                    return warpField;
                });
        };

        return WarpField;
    }])
    .service('WarpFieldCache', ['WarpField', function(WarpField){

        function getObjectSignature(obj){
            return Object.keys(obj).join();
        }

        this.store = (clip, field) => {
            localStorage.setItem(clip.name, JSON.stringify(field));
        };

        this.retrieve = (clip) => {
            var warpField = JSON.parse(localStorage.getItem(clip.name)),
                signature = getObjectSignature(warpField || {});

            if(signature !== getObjectSignature(new WarpField())){
                localStorage.setItem(clip.name, '');
                return null;
            }

            return warpField;
        }
    }])
    .constant('Shapes', Object.freeze({
        Triangle: 'Triangle',
        Quadrilateral: 'Quadrilateral'
    }))
    .service('WarpCamera', ['MalletMath', 'MEasel', 'Shapes', function (MM, MEasel, Shapes) {

        var self = this;

        this.getLensAngle = () => {
            var focalLength = 5;
            return Math.atan(1 / focalLength);
        };

        //position of the camera in 3d space
        this.position = MM.vec3(0, .2, 0);

        /**
         * Draws a rectangle in the Z plane - derived from Hammer code
         * @param shape
         * @param pos {Vector3}
         * @param width {Number} size of shape on x-axis
         * @param depth {Number} size of shape on z-axis
         * @param zRot {Number} rotation on z-axis
         */
        this.fillFlatShape = function(shape, pos, width, depth, zRot){
            //Don't draw things that are in front of the camera
            if(pos.z <= 0){
                return;
            }

            var pts = [];

            if(shape === Shapes.Triangle){
                pts = [
                    MM.vec3(-width / 2, 0, 0),
                    MM.vec3(0, 0, depth),
                    MM.vec3(+width / 2, 0, 0)];
            }
            else if(shape === Shapes.Quadrilateral){
                pts = [
                    MM.vec3(-width / 2, 0, 0),
                    MM.vec3(-width / 2, 0, depth),
                    MM.vec3(+width / 2, 0, depth),
                    MM.vec3(+width / 2, 0, 0)];
            }

            zRot = zRot || 0;
            var ctx = MEasel.context,
                viewport = MM.vec2(ctx.canvas.width, ctx.canvas.height),
                screenCenter = MM.vec2(viewport.x / 2, viewport.y / 2), //center of the viewport

            //position of the object relative to the camera
            //The Y position is inverted because screen space is reversed in Y
                relPosition = MM.vec3(pos.x - self.position.x, -(pos.y - self.position.y), pos.z - self.position.z),
                lensAngle = self.getLensAngle(); //the viewing angle of the lens, large is more stuff visible

            ctx.save();
            ctx.beginPath();

            //Draw the shape with each point
            pts.forEach((pt, index) => {
                var screenPos = MM.vec2(
                    //x' = x * cos(theta) - y * sin(theta)
                    pt.x * Math.cos(zRot) - pt.y * Math.sin(zRot) + relPosition.x,
                    //y' = y * cos(theta) + x * sin(theta)
                    pt.y * Math.cos(zRot) + pt.x * Math.sin(zRot) + relPosition.y
                );
                
                var fieldRadius = (pos.z + pt.z) * Math.tan(lensAngle); //FOV radius at the point
                //Transform the point into screen space
                screenPos
                    .scale(1 / fieldRadius) //1. Scale by the depth of the point
                    .mult(viewport)         //2. Scale to the size of the viewport
                    .add(screenCenter);     //3. Move relative to the screen center

                //Add the point to the path (move for the first point)
                (index === 0 ? ctx.moveTo : ctx.lineTo)(screenPos.x, screenPos.y);
            });

            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
    }])
    .service('WarpShip', ['MScheduler', 'WarpCamera', 'MEasel', 'MalletMath', 'MKeyboard', 'MKeys', 'Shapes', function(MScheduler, WarpCamera, MEasel, MM, MKeyboard, MKeys, Shapes){
        var self = this,
            velocity = MM.vec3(0),
            destLane = 0,
            moveSpeed = 0.0003,
            laneWidth = .05,
            shipWidth = .03,
            pos = MM.vec3(- laneWidth, .1, 1.25),
            bankAngle = 0,
            moving = false;

        this.lane = 0;

        function isSwitchingLanes() {
            return destLane !== self.lane;
        }

        function getSwitchDirection(){
            return (destLane - self.lane)
        }

        function hasReachedLane(){
            var lanePos = (destLane - 1) * laneWidth;
            return getSwitchDirection() > 0 ? pos.x >= lanePos : pos.x <= lanePos;
        }

        MKeyboard.onkeydown(MKeys.Left, () => {
            if(self.lane > 0 && !isSwitchingLanes()){
                destLane = self.lane - 1;
            }
        });

        MKeyboard.onkeydown(MKeys.Right, () => {
            if (self.lane < 2 && !isSwitchingLanes()){
                destLane = self.lane + 1;
            }
        });

        MScheduler.schedule(dt => {

            if(isSwitchingLanes()){
                bankAngle = getSwitchDirection() * Math.PI / 4;
                pos.x += getSwitchDirection() * moveSpeed * dt;
                if(hasReachedLane()){
                    pos.x = (destLane - 1) * laneWidth;
                    self.lane = destLane;
                    bankAngle = 0;
                }
            }

            MScheduler.draw(() => {
                //Draw Ship
                MEasel.context.fillStyle = '#f00';
                WarpCamera.fillFlatShape(Shapes.Triangle, pos, shipWidth, 1, bankAngle);

                //Draw Shadow
                MEasel.context.fillStyle = 'rgba(0,0,0,.25)';
                WarpCamera.fillFlatShape(Shapes.Triangle, MM.vec3(pos.x, 0, 1.25), shipWidth * Math.cos(bankAngle), 1);
            }, 10);
        });
    }])
    .service('WarpAudio', [function(){

    }])
    .service('Warp', function (MApp, MKeyboard, MKeys, AudioClipService, AutoPlay, MediaStates, MScheduler, MEasel, AudioPlayerService, WaveformAnalyzer, WarpFieldCache, $q, WarpField, WarpCamera, MState, WarpShip, Shapes, MalletMath) {
        
        var audioField = [],
            barQueue = [],
            barsVisible = 45,
            velocity = 0,
            state = MState.LOADING,
            timeStep = NaN; //this is NaN so that if it doesn't get set we don't get an endless while loop

        var elapsed = 0, //elapsed time since last bar was rendered
            barOffset = 0, //this value allows the bar to "flow" instead of "jump"

            frequencies = [], //the set of waveform frequencies to average to determine bar width/speed
            frequencySamples = 10, //how many waveform frequencies to average

            barIndex = 0; //where we are in the level

        function getWarpField(clip) {
            var cachedField = WarpFieldCache.retrieve(clip);
            if(cachedField){
                return $q.when(cachedField);
            }
            else {
                return WarpField.generate(clip).then(warpField => {
                    WarpFieldCache.store(clip, warpField);
                    return warpField;
                })
            }

        }

        function playClip(clipId){
            var clip = AudioClipService.getAudioClip(clipId);

            if(!clip.state === MediaStates.READY){
                return;
            }

            state = MState.Loading;

            //reset level variables
            barQueue = [];
            elapsed = 0;
            velocity = 0;
            barIndex = 0;
            frequencies = [];

            getWarpField(clip).then(function(warpField){
                timeStep = warpField.timeStep;
                audioField = warpField.gems;

                //Play the clip - this can take time to initialize
                return AudioPlayerService.playClip(clip.id).then(()=>{
                    state = MState.Running;

                    //Don't start playing the song if game is paused
                    if(MApp.hasState(MState.Suspended)){
                        AudioPlayerService.pause();
                    }
                });
            });
        }

        /**
         * Initialize Game
         */
        this.init = () => {
            MScheduler.suspendOnBlur(); //Suspend the event loop when the window is blurred
            AudioPlayerService.registerPlayer(); //init the audio player service
            MScheduler.schedule(update); //when the clip actually begins playing start the level
            AudioClipService.getClipList() //wait for clips to load
                .then(AudioClipService.loadAudioClips)
                .then(function() {
                    playClip(AutoPlay);
                });

            //Setup state events
            MApp.onState(MState.Suspended, AudioPlayerService.pause);
            MApp.onState(MState.Running, AudioPlayerService.resume);
            MKeyboard.onkeydown(MKeys.Escape, () => { //Escape key toggles playing
                MApp.hasState(MState.Running) ? MScheduler.suspend() : MScheduler.resume()
            });
        };

        /**
         * Get the average value of an array of numbers
         * @param arr
         * @returns {*}
         */
        function getAvg(arr) {
            return arr.reduce((avg, value) => avg + value / arr.length, 0);
        }

        /**
         * This is the main loop function for Warp
         * @param dt deltaTime
         */
        function update(dt) {

            if(state !== MState.Running) {
                return;
            }

            //advance through the level
            elapsed += dt;
            /**
             * This creates a sort of independent fixed update the ensures the level follows the song
             * Each bar the screen represents a fixed amount of time, and no matter how wide, can only
             * remain on screen for the duration for everything to stay in sync
             */
            while(elapsed > timeStep / 1000){
                elapsed -= (timeStep || NaN); //break if timeStep is not set
                barIndex++;
                barOffset = 0; //reset the bar offset

                //remove the bar that just moved off screen
                barQueue.shift();

                var waveform = WaveformAnalyzer.getMetrics();
                //Create a new bar
                while(barQueue.length < barsVisible){
                    //get the current waveform frequency and remove the oldest value
                    frequencies.push(((1 / waveform.period) / 10));
                    if(frequencies.length > frequencySamples){
                        frequencies.shift();
                    }

                    //add a new bar to the queue
                    barQueue.push({
                        speed: .7 + .3 * getAvg(frequencies) //this value is basically fudged to work well
                    });
                }
            }


            //Add a draw command for the frame
            MScheduler.draw(()=>{
                var ctx = MEasel.context,
                    barHeight = ctx.canvas.height / barsVisible,
                    barMargin = 10, //space between bars
                    barWidth = .45; //width of the bars

                //how fast the set of bars is moving across the screen
                velocity = (barHeight * barQueue[0].speed + barMargin) / timeStep;
                barOffset += velocity * dt;
                //make the first bar yellow
                ctx.fillStyle = '#ff0';
                var drawOffset = 200; //this spaces the bars correctly across the screen, 200 is based on how far above the plane the camera is
                for(var i = 0; i < barsVisible; i++){
                    var drawWidth = barWidth * audioField[barIndex + i],
                        pos = MalletMath.vec3(0, 0, (drawOffset - barOffset) / 100);
                    WarpCamera.fillFlatShape(Shapes.Quadrilateral, pos, drawWidth, (barHeight * barQueue[i].speed) / 100);
                    drawOffset += barHeight * barQueue[i].speed + barMargin; //add the width the current bar (each bar has a different width)
                    ctx.fillStyle = '#fff';
                }
            }, 5);
        }

        /**
         * Debugging stuff
         */
        var imgData;
        function debugDraw() {
            MScheduler.postProcess(() => {
                var ctx = MEasel.context;

                if(!audioField.length)
                    return;

                var start = 0,
                    rows = 750;
                // i) get all of the rgba pixel data of the canvas by grabbing the imageData Object
                imgData = imgData || ctx.getImageData(100, 100, 512, rows);

                var data = imgData.data,
                    length = data.length;

                //Renders FFT data
                // for(var i = start; i < audioField.length; i += 5){
                //     for(var f = 0; f < audioField[i].length; f++){
                //         var value = 255 * audioField[i][f] * 10;
                //         var row = (i - start) * 512 * 4 / 5;
                //         data[row + f * 4] = value;
                //         data[row + f * 4 + 1] = value;
                //         data[row + f * 4 + 2] = value;
                //         data[row + f * 4 + 3] = 255;
                //     }
                //
                //     if(i > start + rows * 5){
                //         break;
                //     }
                // }

                //Renders loudness Data
                for(var i = start; i < audioField.length; i += 5){
                    for(var f = 0; f < 512; f++){
                        var value = 255 * audioField[i];
                        var row = (i - start) * 512 * 4 / 5;
                        data[row + f * 4] = value;
                        data[row + f * 4 + 1] = value;
                        data[row + f * 4 + 2] = value;
                        data[row + f * 4 + 3] = 255;
                    }

                    if(i > start + rows * 5){
                        break;
                    }
                }

                ctx.putImageData(imgData, 200, 100);
            });
        }

        //MScheduler.schedule(debugDraw);

    });