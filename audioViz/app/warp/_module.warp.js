/**
 * Created by gjrwcs on 10/25/2016.
 */
"use strict";
angular.module('pulsar-warp', [])
    .factory('WarpField', ['MConcurrentOperation', 'AudioData', 'SampleCount', function(MConcurrentOperation, AudioData, SampleCount){
        //Create a web worker with the analysis script
        var fieldGenerator = MConcurrentOperation.create('assets/js/workers/generateAudioField.js');

        function WarpField(){
            //Defining a version as a key so that the 'signature' of the object
            //can be compared without analyzing any specific property
            Object.defineProperty(this, 'v1.28', {configurable: false, value: 1, enumerable: true});
            this.duration = 0;
            this.timeStep = NaN;
            this.level = null;
        }

        /**
         * Performs analysis to generate "audio field" and then begins play
         * @param clip
         */
        WarpField.generate = (clip) => {
            var warpField = new WarpField();
            //This function renders all of the PCM data for the entire clip into series of buffers
            //The result thousands of buckets of 1024 samples (~800 per minute of play w/ current config)
            return AudioData.renderFrameBuffers(clip)
                .then(result => {
                    warpField.duration = result.duration;
                    //this is the average duration of time for each buffer created
                    warpField.timeStep = (result.duration / result.frameBuffers.length) * 1000;

                    //Invoke the analysis in a separate thread (using a web worker)
                    return fieldGenerator.invoke({
                        sampleRate: result.sampleRate, //How many samples per second
                        frequencyBinCount: SampleCount, //The number of frequency bins
                        frameBuffers: result.frameBuffers //The actual array of frame buffers
                    });
                }).then(result => {
                    warpField.level = result.audioField; //The "level" generated by the async web worker
                    return warpField;
                });
        };

        return WarpField;
    }])
    .service('WarpFieldCache', ['WarpField', function(WarpField){

        function getObjectSignature(obj){
            return Object.keys(obj).join();
        }

        this.store = (clip, field) => {
            localStorage.setItem(clip.name, JSON.stringify(field));
        };

        this.retrieve = (clip) => {
            var warpField = JSON.parse(localStorage.getItem(clip.name)),
                signature = getObjectSignature(warpField || {});

            if(signature !== getObjectSignature(new WarpField())){
                localStorage.setItem(clip.name, '');
                return null;
            }

            return warpField;
        }
    }])
    .constant('Shapes', Object.freeze({
        Triangle: 'Triangle',
        Quadrilateral: 'Quadrilateral'
    }))
    .service('WarpShip', ['MScheduler', 'MCamera', 'MEasel', 'MalletMath', 'MKeyboard', 'MKeys', 'Shapes', 'WarpLevel', 'WarpState', 'Geometry', function(MScheduler, MCamera, MEasel, MM, MKeyboard, MKeys, Shapes, Warp, WarpState, Geometry){
        var self = this,
            velocity = MM.vec3(0),
            destLane = 0,
            moveSpeed = 0.0003,
            laneWidth = .05,
            shipWidth = .03,
            pos = MM.vec3(- laneWidth, .1, 20),
            bankAngle = 0,
            moving = false;

        this.lane = 0;
        this.score = 0;

        function isSwitchingLanes() {
            return destLane !== self.lane;
        }

        function getSwitchDirection(){
            return (destLane - self.lane)
        }

        function hasReachedLane(){
            var lanePos = (destLane - 1) * laneWidth;
            return getSwitchDirection() > 0 ? pos.x >= lanePos : pos.x <= lanePos;
        }

        function cancelLaneSwitch(dir){
            destLane = self.lane;
            bankAngle = 0;
            pos.x = (self.lane - 1) * laneWidth;
        }

        //MKeyboard.onKeyUp(MKeys.Left, ()=>cancelLaneSwitch);
        //MKeyboard.onKeyUp(MKeys.Right, cancelLaneSwitch);

        WarpState.onState(WarpState.Loading, ()=>{self.score = 0});

        var transforms = new Array(20);

        for(var i = 0; i < 20; i++){
            transforms[i] = new Geometry.Transform();
            transforms[i].position = MM.vec3(-5 + i * .5, 0, 10.3);
            transforms[i].scale = MM.vec3(.35);
            //MCamera.render(Geometry.meshes.Cube, transform, "#f0f");
        }

        MScheduler.schedule(dt => {

            if(isSwitchingLanes()){
                bankAngle = getSwitchDirection() * Math.PI / 4;
                pos.x += getSwitchDirection() * moveSpeed * dt;
                if(hasReachedLane()){
                    pos.x = (destLane - 1) * laneWidth;
                    self.lane = destLane;
                    bankAngle = 0;
                }
            } else {
                if(MKeyboard.isKeyDown(MKeys.Left) && self.lane > 0){
                    destLane = self.lane - 1;
                }

                if(MKeyboard.isKeyDown(MKeys.Right) && self.lane < 2){
                    destLane = self.lane + 1;
                }
            }

            var collectOffset = 2;
            if(Warp.warpField && Warp.warpField[Warp.sliceIndex + collectOffset]){
                Warp.warpField[Warp.sliceIndex + collectOffset].gems.forEach((gem, lane) => {
                    if(gem === 1 && lane === self.lane){
                        self.score++;
                        Warp.warpField[Warp.sliceIndex + collectOffset].gems[lane] = 2;
                    }
                });
            }

            MScheduler.draw((dt, et) => {
                //Draw Ship
                MEasel.context.fillStyle = '#f00';
                MCamera.drawShape(Shapes.Triangle, pos, shipWidth, 10, bankAngle);

                //Draw Shadow
                MEasel.context.fillStyle = 'rgba(0,0,0,.25)';
                MCamera.drawShape(Shapes.Triangle, MM.vec3(pos.x, 0, 20), shipWidth * Math.cos(bankAngle), 10, 0);

                //var transform = new Geometry.Transform();
                for(var i = 0; i < 20; i++){
                    transforms[i].rotation = MM.vec3(et / 1000);
                    //MCamera.render(Geometry.meshes.Cube, transform, "#f0f");
                }

                //MCamera.render(Geometry.meshes.Cube, transforms, "#f0f");

            }, 10);
        });
    }])
    .factory('WarpBar', ['MalletMath', function(MM){
        return {
            //dimensions of the flanking bars
            scale: MM.vec3(1.5, 1, .9),
            margin: .01
        }
    }])
    .service('WarpState', [function(){

        var state,
            stateListeners = [];

        /**
         * Invokes callbacks for events listening for the given state
         * @param state
         */
        function invokeStateListeners(state) {
            stateListeners.forEach(listener => {
                if((listener.state | state) === state){
                    listener.callback();
                }
            });
        }

        /**
         * Creates an event listener for the given state
         * @param state
         * @param callback
         */
        this.onState = (state, callback) => {
            stateListeners.push({
                state: state,
                callback: callback
            });
        };

        Object.defineProperties(this, {
            'current': {get: ()=>state, set: value =>{ state = value; invokeStateListeners(state)}},

            'Paused': {value: 1, enumerable: true},
            'Playing': {value: 2, enumerable: true},
            'LevelComplete': {value: 4, enumerable: true},
            'Loading': {value: 8, enumerable: true}
        });

        this.is = (checkState) => {
            //Checks if the current state is included in the check state
            return (checkState | state) === state;
        };

        state = this.Loading;
    }])
    .service('WarpFieldDraw', ['MScheduler', 'WarpLevel', 'MalletMath', 'MEasel', 'WarpState', 'MCamera', 'Shapes', 'Geometry', 'WarpBar', function(MScheduler, WarpLevel, MM, MEasel, WarpState, MCamera, Shapes, Geometry, Bar){
        var velocity = 0,
            meshes = Geometry.meshes,
            Transform = Geometry.Transform;

        var laneWidth = .05, //width of each lane
            lanePadding = .0025, //padding on edge of each lane

            mLaneWidth = .20,
            mLanePadding = .01,

        tLane = new Transform();
        tLane.scale.x = mLaneWidth - mLanePadding;
        tLane.scale.z = 20;
        tLane.position.z = 1;
        tLane.position.y = -.1;


        var gems = new Array(WarpLevel.barsVisible);
        for(var g = 0; g < gems.length; g++){
            gems[g] = new Transform();
            //gems[g].position.y = -.5;
            gems[g].rotation.y = Math.PI / 4;
            gems[g].rotation.x = Math.PI / 4;
            gems[g].scale = MM.vec3(.25);
        }

        var tBar = new Transform();
        tBar.origin.x = -1;

        function draw(dt){
            var ctx = MEasel.context,
                startOffset = -4,
                zRot = - Math.PI / 8; //rotation of loudness bars on the edges

            WarpLevel.barOffset += velocity * dt;
            //make the first bar yellow
            ctx.fillStyle = '#ff0';

            var drawOffset = -Bar.scale.z + startOffset; //this spaces the bars correctly across the screen, 200 is based on how far above the plane the camera is
            for(var i = 0; i < WarpLevel.barsVisible; i++){
                if(i === 2){
                    ctx.fillStyle = '#fff';
                }
                else if(i + 5 > WarpLevel.barsVisible){
                    ctx.fillStyle = 'rgba(255,255,255,' + (WarpLevel.barsVisible - i) / 5 + ')';
                }

                var depth = Bar.scale.z * WarpLevel.barQueue[i].speed,
                    zOffset = drawOffset - WarpLevel.barOffset;

                tBar.scale.x = Bar.scale.x * WarpLevel.getLoudness(i);
                tBar.scale.z = depth;

                tBar.position = MM.vec3(mLaneWidth, 0, zOffset);
                tBar.rotation.z = zRot;
                MCamera.render(meshes.XZQuad, tBar, "#fff");

                var sliceGems = (WarpLevel.warpField[WarpLevel.sliceIndex + i] || {}).gems || [];
                gems[i].scale = MM.vec3(0);
                for(var l = 0; l < 3; l++){
                    if(sliceGems[l] === 1){
                        gems[i].scale = MM.vec3(.25);
                        gems[i].position = MM.vec3((l - 1) * mLaneWidth * 3, -.5, zOffset);
                    }
                }

                drawOffset += depth + Bar.margin ; //add the width the current bar (each bar has a different width)
            }

            tLane.position.x = -mLaneWidth;
            MCamera.render(meshes.XZQuad, tLane, '#ccc');
            tLane.position.x = 0;
            MCamera.render(meshes.XZQuad, tLane, '#ccc');
            tLane.position.x = mLaneWidth;
            MCamera.render(meshes.XZQuad, tLane, '#ccc');

            MCamera.render(meshes.Cube, gems, '#0f0');
        }

        this.init = () => {
            MScheduler.schedule(()=>{
                if(WarpState.current !== WarpState.Playing) {
                    return;
                }

                MScheduler.draw(draw);
            });
        }

    }])
    .service('WarpLevel', ['MScheduler', 'WarpState', 'WaveformAnalyzer', 'WarpBar', function(MScheduler, WarpState, WaveformAnalyzer, Bar){
        var self = this;
        this.barQueue = [0];
        this.barsVisible = 55;
        self.timeStep = NaN; //this s NaN so that if it doesn't get set we don't get an endless while loop

        this.warpField = null;
        this.sliceIndex = 0; //where we are in the level

        var elapsed = 0; //elapsed time since last bar was rendered
        this.barOffset = 0;  //this value allows the bar to "flow" instead of "jump"

        this.frequencies = []; //the set of waveform frequencies to average to determine bar width/speed
        var frequencySamples = 10; //how many waveform frequencies to average

        this.reset = function(){
            //reset level variables
            self.barQueue = [0, 0, 0];
            elapsed = 0;
            self.sliceIndex = 0;
            self.frequencies = [];
            self.timeStep = NaN;
            self.barOffset = 0;
        };

        this.load = warpField => {
            self.timeStep = warpField.timeStep;
            console.log(self.timeStep);
            self.warpField = warpField.level;
        };

        this.getLoudness = relativeIndex => {
            return (self.warpField[self.sliceIndex + relativeIndex] || {}).loudness || 0;
        };

        /**
         * Get the average value of an array of numbers
         * @param arr
         * @returns {*}
         */
        function getAvg(arr) {
            return arr.reduce((avg, value) => avg + value / arr.length, 0);
        }

        /**
         * Update the various properties of the game level
         */
        MScheduler.schedule((dt) => {
            if(WarpState.current !== WarpState.Playing) {
                return;
            }

            //advance through the level
            elapsed += dt;
            /**
             * This creates a sort of independent fixed update the ensures the level follows the song
             * Each bar the screen represents a fixed amount of time, and no matter how wide, can only
             * remain on screen for the duration for everything to stay in sync
             */
            while(elapsed > self.timeStep / 1000){
                elapsed -= (self.timeStep || NaN); //break if timeStep is not set
                self.sliceIndex++;
                self.barOffset = 0; //reset the bar offset

                //remove the bar that just moved off screen
                self.barQueue.shift();

                var waveform = WaveformAnalyzer.getMetrics();
                //Create a new bar
                while(self.barQueue.length < self.barsVisible){
                    //get the current waveform frequency and remove the oldest value
                    self.frequencies.push(((1 / waveform.period) / 10));
                    if(self.frequencies.length > frequencySamples){
                        self.frequencies.shift();
                    }

                    //add a new bar to the queue
                    self.barQueue.push({
                        speed: .9 + .1 * getAvg(self.frequencies) //this value is basically fudged to work well
                    });
                }
            }

            //how fast the set of bars is moving across the screen
            var velocity = (Bar.scale.z * self.barQueue[2].speed + Bar.margin) / self.timeStep;
            self.barOffset += dt * velocity;

            if(self.sliceIndex > self.warpField.length){
                WarpState.current = WarpState.LevelComplete;
            }
        });
    }])
    //Still a little ugly, but this is workable...
    .service('Warp', function (WarpFieldDraw, WarpLevel, WarpState, MState, MKeyboard, MKeys, AudioClipService, AutoPlay, MediaStates, MScheduler, AudioPlayerService, WarpFieldCache, $q, WarpField) {
        
        var self = this;

        function getWarpField(clip) {
            var cachedField = WarpFieldCache.retrieve(clip);
            if(cachedField){
                return $q.when(cachedField);
            }
            else {
                return WarpField.generate(clip).then(warpField => {
                    WarpFieldCache.store(clip, warpField);
                    return warpField;
                })
            }

        }

        this.playClip = function(clipId){
            var clip = AudioClipService.getAudioClip(clipId);

            if(!clip.state === MediaStates.READY){
                return;
            }

            WarpState.current = WarpState.Loading;
            WarpLevel.reset();

            //Stop any song that's playing
            AudioPlayerService.stop();

            getWarpField(clip).then(function(warpField){
               WarpLevel.load(warpField);

                //Play the clip - this can take time to initialize
                return AudioPlayerService.playClip(clip.id).then(()=>{
                    WarpState.current = WarpState.Playing;

                    //Don't start playing the song if game is paused
                    if(MState.is(MState.Suspended)){
                        WarpState.current = WarpState.Paused;
                        AudioPlayerService.pause();
                    }
                });
            });
        };

        /**
         * Initialize Game
         */
        this.init = () => {
            WarpFieldDraw.init();
            MScheduler.suspendOnBlur(); //Suspend the event loop when the window is blurred
            AudioPlayerService.registerPlayer(); //init the audio player service
            AudioClipService.getClipList() //wait for clips to load
                .then(AudioClipService.loadAudioClips)
                .then(function() {
                    self.playClip(AutoPlay);
                });

            //Setup state events
            MState.onState(MState.Suspended, () => {
                if(WarpState.is(WarpState.Playing)){
                    WarpState.current = WarpState.Paused;
                    AudioPlayerService.pause();
                }
            });

            MState.onState(MState.Running, () => {
                if(WarpState.is(WarpState.Paused)){
                    WarpState.current = WarpState.Playing;
                    AudioPlayerService.resume();
                }
            });

            MKeyboard.onKeyDown(MKeys.Escape, () => { //Escape key toggles playing
                if(WarpState.is(WarpState.Playing) || WarpState.is(WarpState.Paused)) {
                    MState.is(MState.Running) ? MScheduler.suspend() : MScheduler.resume()
                }
            });
        };
    });